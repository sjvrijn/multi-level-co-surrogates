#!/usr/bin/python
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, print_function, unicode_literals

'''
post_process.py: This file is intended to perform some simple post-processing
                 based on the data files generated by the CMA-ES.
'''

__author__ = 'Sander van Rijn'
__email__ = 's.j.van.rijn@liacs.leidenuniv.nl'

from multiLevelCoSurrogates.config import experiment_repetitions, fit_funcs, fit_func_dims, folder_name, suffix, training_sizes, data_ext, plot_ext, data_dir, plot_dir, base_dir
from multiLevelCoSurrogates.__main__ import guaranteeFolderExists
from itertools import product
from matplotlib import pyplot as plt
from collections import Counter, namedtuple

from pprint import pprint
import numpy as np

surrogates = ['Kriging', 'RBF', 'RandomForest', 'NoSurrogate']  # , 'SVM'
uses = ['reg', 'MF', 'scaled-MF', 'MF-bisurr', 'scaled-MF-bisurr']  # , 'EGO-reg']
gen_intervals = [0, 1, 2, 3, 5, 10, 20]
lambda_pres = [0, 10, 20, 30, 40, 50]



def isTwoInts(value):
    """Returns True if the given value is a tuple or list consisting of exactly 2 integers"""
    return isinstance(value, (tuple, list)) \
           and len(value) == 2 \
           and all(isinstance(val, int) for val in value)


#TODO: rewrite to use slice()
def interpretColumn(column):
    """Interprets the 'column' argument of loadFitnessHistory into a start, end value pair"""
    if column is None:  # No specific column is requested, return everything
        start = 0
        end = None
    elif isinstance(column, int):  # One specific column is requested
        start = column
        end = column + 1
    elif isTwoInts(column):  # Multiple columns are requested
        start = column[0]
        end = column[1] + 1 if column[1] != -1 else None  # if -1 is given, we want up to and incl. the last column
    else:  # 'column' does not match expected format
        raise Exception("Invalid format for 'column': {col}".format(col=column))

    return start, end


def loadFitnessHistory(fname, column=None):
    """
    Return the data stored in the given filename as float values.
    Optionally, only data from a single, or range of columns can be selected.

    :param fname: The name of the file to retrieve the data from
    :param column:   Single or double integer to indicate desired column (optional)
    :return:         (Selected) data from the given file in 2D list format
    """

    start, end = interpretColumn(column)

    with open(fname, 'r') as f:
        next(f)  # Skip the first line which only contains header information
        return [list(map(float, line.split(' ')[start:end])) for line in f]


#=======================================================================================================================
#=======================================================================================================================
#=======================================================================================================================


def plotSimpleComparisons(training_size):
    """Create and save plots comparing convergence of different uses of the same surrogate"""

    experiment_repetitions = experiment_repetitions
    fit_func_names = fit_funcs.keys()
    # surrogates = ['Kriging', 'RBF', 'RandomForest']
    # uses = ['reg', 'MF', 'scaled-MF']
    experiments = product(fit_func_names, surrogates, range(experiment_repetitions))

    for fit_func_name, surrogate_name, rep in experiments:
        print(fit_func_name, surrogate_name, rep)

        ndim = fit_func_dims[fit_func_name]
        fsuff = suffix.format(size=training_size, rep=rep)
        plt.figure()

        for use in uses:

            if surrogate_name == 'NoSurrogate' and use is not 'reg':
                continue
            elif use == 'EGO-reg' and surrogate_name is not 'Kriging':
                continue

            fname = folder_name.format(ndim=ndim, func=fit_func_name, use=use, surr=surrogate_name)
            filename_prefix = f'{data_dir}{fname}{fsuff}'

            data = np.array(loadFitnessHistory(filename_prefix + 'reslog.' + data_ext, column=(1, -1)))
            data = np.ma.masked_invalid(data).min(axis=1)
            data = np.minimum.accumulate(data)
            plt.plot(data, label=use)

        plot_folder = folder_name.format(ndim=ndim, func=fit_func_name, use='', surr=surrogate_name)
        plot_name_prefix = f'{plot_dir}{plot_folder}{fsuff}'
        guaranteeFolderExists(f'{plot_dir}{plot_folder}')
        plt.xlabel('Evaluations')
        plt.ylabel('Fitness value')
        plt.legend(loc=0)
        plt.savefig(plot_name_prefix + 'reslog.' + plot_ext)
        plt.close()


def plotMedianComparisons(training_size):
    """Create and save plots comparing the median convergence of `experiment_repetitions` runs for various uses of each surrogate"""

    experiment_repetitions = experiment_repetitions
    fit_func_names = fit_funcs.keys()
    # surrogates = ['Kriging', 'RBF', 'RandomForest']
    # uses = ['reg', 'MF', 'scaled-MF']
    experiments = product(fit_func_names, surrogates)

    for fit_func_name, surrogate_name in experiments:
        print(fit_func_name, surrogate_name)

        ndim = fit_func_dims[fit_func_name]
        plt.figure()

        for use in uses:

            if surrogate_name == 'NoSurrogate' and use is not 'reg':
                continue
            elif use == 'EGO-reg' and surrogate_name is not 'Kriging':
                continue

            fname = folder_name.format(ndim=ndim, func=fit_func_name, use=use, surr=surrogate_name)
            total_data = []

            for rep in range(experiment_repetitions):
                fsuff = suffix.format(size=training_size, rep=rep)
                filename_prefix = f'{data_dir}{fname}{fsuff}'

                data = np.array(loadFitnessHistory(filename_prefix + 'reslog.' + data_ext, column=(1, -1)))
                data = np.ma.masked_invalid(data).min(axis=1)
                data = np.minimum.accumulate(data)
                total_data.append(data)

            min_idx = np.argmin(np.asarray([dat[-1] for dat in total_data]))
            plt.plot(total_data[min_idx], label=f'median {use}')


            # Make all arrays in total_data of equal length and calculate the average
            max_len = max([len(dat) for dat in total_data])
            new_data = []
            for dat in total_data:
                new_data.append(np.ma.append(dat, [dat[-1]] * (max_len - len(dat))))
            plt.plot(np.mean(np.vstack(new_data), axis=0), label=f'mean {use}')



        fsuff = suffix.format(size=training_size, rep='')
        plot_folder = f'{fit_func_name}-{surrogate_name}-'
        plot_name_prefix = f'{plot_dir}{plot_folder}{fsuff}'
        guaranteeFolderExists(f'{plot_dir}')
        plt.xlabel('Evaluations')
        plt.ylabel('Fitness value')
        plt.yscale('log')
        plt.legend(loc=0)
        plt.savefig(plot_name_prefix + 'reslog.' + plot_ext)
        plt.close()


def counterToFilledTupleList(counter):
    """Transform a counter into a list of (entry, count)-tuples, explicitly keeping 0-counts"""
    result = []
    for usage in ['reg', 'MF', 'scaled-MF']:
        result.append((usage, counter[usage]))
    return result


def calcWinsPerStrategy(training_size):
    """Compare the medians of `experiment_repetitions` runs of each use to determine 'wins', and plot these as a histogram"""

    experiment_repetitions = experiment_repetitions
    fit_func_names = fit_funcs.keys()
    # surrogates = ['Kriging', 'RBF', 'RandomForest']
    # uses = ['reg', 'MF', 'scaled-MF']
    experiments = product(fit_func_names, surrogates)

    c = Counter()
    surr_c = {name: Counter() for name in surrogates}
    func_c = {name: Counter() for name in fit_func_names}

    for fit_func_name, surrogate_name in experiments:
        print(fit_func_name, surrogate_name)

        ndim = fit_func_dims[fit_func_name]
        best_res = {}

        for use in uses:

            fname = folder_name.format(ndim=ndim, func=fit_func_name, use=use, surr=surrogate_name)
            total_data = []

            for rep in range(experiment_repetitions):
                fsuff = suffix.format(size=training_size, rep=rep)
                filename_prefix = f'{data_dir}{fname}{fsuff}'

                data = np.array(loadFitnessHistory(filename_prefix + 'reslog.' + data_ext, column=(1, -1)))
                data = np.ma.masked_invalid(data).min(axis=1)
                data = np.minimum.accumulate(data)
                total_data.append(data)

            bests = np.asarray([dat[-1] for dat in total_data])
            best_res[use] = np.argsort(bests)[len(bests) // 2]

        if best_res['reg'] < best_res['MF'] and best_res['reg'] < best_res['scaled-MF']:
            c['reg'] += 1
            surr_c[surrogate_name]['reg'] += 1
            func_c[fit_func_name]['reg'] += 1
        elif best_res['MF'] < best_res['reg'] and best_res['MF'] < best_res['scaled-MF']:
            c['MF'] += 1
            surr_c[surrogate_name]['MF'] += 1
            func_c[fit_func_name]['MF'] += 1
        else:
            c['scaled-MF'] += 1
            surr_c[surrogate_name]['scaled-MF'] += 1
            func_c[fit_func_name]['scaled-MF'] += 1

    pprint(func_c)
    print()
    pprint(surr_c)
    print()
    pprint(c)

    plt.figure(figsize=(4,4))
    plt.suptitle(f'Wins per usage type, training size = {training_size}')
    plt.subplot(211)
    # plt.title('Combined wins per usage type')
    # ids, vals = zip(*counterToFilledTupleList(c))
    # plt.hist(range(len(ids)), weights=vals)
    # plt.xticks(range(len(ids)), ids)

    ax1 = plt.subplot(211)
    ax1.set_title('by surrogate')
    indices = []
    values = []
    labels = []
    for name, counter in surr_c.items():
        ids, vals = zip(*counterToFilledTupleList(counter))
        indices.append(range(len(ids)))
        values.append(vals)
        labels.append(name)
    ax1.hist(indices, bins=np.arange(4)-.5, weights=values, label=labels, stacked=True, align='mid', rwidth=.5)
    ax1.set_xticks(range(len(ids)))
    ax1.set_xticklabels(ids)

    ax2 = plt.subplot(212)
    ax2.set_title('by benchmark function')
    indices = []
    values = []
    labels = []
    for name, counter in func_c.items():
        ids, vals = zip(*counterToFilledTupleList(counter))
        indices.append(range(len(ids)))
        values.append(vals)
        labels.append(name)
    ax2.hist(indices, bins=np.arange(4)-.5, weights=values, label=labels, stacked=True, align='mid', rwidth=.5)
    ax2.set_xticks(range(len(ids)))
    ax2.set_xticklabels(ids)

    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    # plt.tight_layout()
    #
    # box = ax1.get_position()
    # ax1.set_position([box.x0, box.y0, box.width * 0.65, box.height])
    # ax1.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    #
    # box = ax2.get_position()
    # ax2.set_position([box.x0, box.y0, box.width * 0.65, box.height])
    # ax2.legend(loc='center left', bbox_to_anchor=(1, 0.5))


    fsuff = suffix.format(size=training_size, rep='')
    plot_name_prefix = f'{plot_dir}{fsuff}'
    guaranteeFolderExists(f'{plot_dir}')
    plt.savefig(plot_name_prefix + 'reslog-histogram_no-legend.' + plot_ext)


def plotBoxPlots(training_size):
    """Create and save boxplots for the final fitness levels and time to convergence"""

    experiment_repetitions = experiment_repetitions
    fit_func_names = fit_funcs.keys()
    # surrogates = ['Kriging', 'RBF', 'RandomForest']
    # uses = ['reg', 'MF', 'scaled-MF']
    experiments = product(fit_func_names, surrogates)

    for fit_func_name, surrogate_name in experiments:
        print(fit_func_name, surrogate_name)

        plt.figure()
        ndim = fit_func_dims[fit_func_name]
        bests = []
        lengths = []

        for use in uses:

            if surrogate_name == 'NoSurrogate' and use is not 'reg':
                continue
            if use == 'EGO-reg' and surrogate_name is not 'Kriging':
                continue
            fname = folder_name.format(ndim=ndim, func=fit_func_name, use=use, surr=surrogate_name)
            total_data = []
            total_lengths = []

            for rep in range(experiment_repetitions):
                fsuff = suffix.format(size=training_size, rep=rep)
                filename_prefix = f'{data_dir}{fname}{fsuff}'

                data = np.array(loadFitnessHistory(filename_prefix + 'reslog.' + data_ext, column=(1, -1)))
                total_lengths.append(len(data))
                data = np.ma.masked_invalid(data).min(axis=1)
                data = np.minimum.accumulate(data)
                total_data.append(data)

            bests.append(np.array([dat[-1] for dat in total_data]))
            lengths.append(total_lengths)

        if surrogate_name == 'Kriging':
            labels = uses
        elif surrogate_name == 'NoSurrogate':
            labels = uses[:1]
        else:
            labels = uses[:3]

        plt.subplot(211)
        plt.title("Fitness values")
        plt.boxplot(bests, labels=labels)
        plt.yscale('log')

        plt.subplot(212)
        plt.title("Time to convergence")
        plt.boxplot(lengths, labels=labels)

        plt.tight_layout()
        fsuff = suffix.format(size=training_size, rep='')
        plot_folder = f'{fit_func_name}-{surrogate_name}-'
        plot_name_prefix = f'{plot_dir}{plot_folder}{fsuff}'
        guaranteeFolderExists(f'{plot_dir}')
        plt.savefig(plot_name_prefix + 'reslog-boxplot.' + plot_ext)
        plt.close()



def getdata():

    fit_func_names = fit_funcs.keys()
    experiments = product(fit_func_names, surrogates, uses, range(experiment_repetitions), gen_intervals, lambda_pres)

    Index = namedtuple('Index', ['fitfunc', 'surrogate', 'usage', 'repetition', 'genint', 'lambda_pre'])
    data = {}

    for fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre in experiments:
        idx = Index(fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre)
        ndim = fit_func_dims[fit_func_name]

        if surrogate_name == 'NoSurrogate' and use is not 'reg':
            continue
        elif use == 'EGO-reg' and surrogate_name not in ['Kriging', 'RandomForest']:
            continue

        fname = folder_name.format(ndim=ndim, func=fit_func_name, use=use, surr=surrogate_name)
        fsuff = suffix.format(size=lambda_pre, rep=rep, gen=gen_int)
        filename_prefix = f'{base_dir}data/{fname}{fsuff}'


        try:
            data[idx] = np.array(loadFitnessHistory(filename_prefix + 'reslog.' + data_ext, column=(1, -1)))
            if fit_func_name == 'borehole':
                data[idx] *= -1
            elif fit_func_name == 'park91b':
                data[idx] -= 0.666666666666  # Manually extracted minimum found value...
            print(fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre)
        except:
            # print(fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre, filename_prefix, "\tNOPE")
            pass

    print("done")
    return data


def getplottingvalues(total_data):

    max_len = max([len(dat) for dat in total_data])
    new_data = [dat.tolist() + [dat[-1]]*(max_len - len(dat)) for dat in total_data]
    new_data = np.stack(new_data)

    # Workaround to prevent negative values
    positive = new_data > 0
    min_pos = np.min(new_data[positive])
    new_data[~positive] = min_pos

    minimum = np.min(new_data, axis=0)
    mean = np.mean(new_data, axis=0)
    median = new_data[np.argsort(new_data[:,-1])[len(new_data)//2]]
    maximum = np.max(new_data, axis=0)



    return minimum, mean, median, maximum


def plot_by_genint(data):
    """Create and save plots comparing the median convergence of `experiment_repetitions`
     runs for various uses of each surrogate"""

    fit_func_names = fit_funcs.keys()

    Index = namedtuple('Index', ['fitfunc', 'surrogate', 'usage', 'repetition', 'genint', 'lambda_pre'])

    np.set_printoptions(precision=3, linewidth=2000)

    for fit_func_name, surrogate_name, use in product(fit_func_names, surrogates, uses):

        if surrogate_name == 'NoSurrogate' and use is not 'reg':
            continue
        elif use == 'EGO-reg' and surrogate_name not in ['Kriging', 'RandomForest']:
            continue

        plt.figure(figsize=(16,9))
        num_plotted = 0

        for gen_int, lambda_pre in product(gen_intervals, lambda_pres):
            total_data = []

            for rep in range(experiment_repetitions):

                try:
                    idx = Index(fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre)
                    dat = data[idx]
                except:
                    continue
                dat = np.ma.masked_invalid(dat).min(axis=1)
                dat = np.minimum.accumulate(dat)
                total_data.append(dat)

            if not total_data:
                continue
            minimum, mean, median, maximum = getplottingvalues(total_data)

            plt.subplot(121)
            plt.plot(median, label=f'{use} g{gen_int} l{lambda_pre}')
            plt.fill_between(np.arange(len(minimum)), minimum, maximum, interpolate=True, alpha=0.2)

            plt.subplot(122)
            plt.plot(mean, label=f'{use} g{gen_int} l{lambda_pre}')
            plt.fill_between(np.arange(len(minimum)), minimum, maximum, interpolate=True, alpha=0.2)
            num_plotted += 1

        if num_plotted <= 1:
            plt.close()
            continue

        guaranteeFolderExists(f'{plot_dir}')
        plt.suptitle('Generation Interval comparison')
        plt.subplot(121)
        plt.title(f'{fit_func_name}-{surrogate_name}-{use} - Medians')
        plt.xlabel('Evaluations')
        plt.ylabel('Fitness value')
        plt.yscale('log')
        plt.legend(loc=0)

        plt.subplot(122)
        plt.title(f'{fit_func_name}-{surrogate_name}-{use} - Means')
        plt.xlabel('Evaluations')
        plt.ylabel('Fitness value')
        plt.yscale('log')
        plt.legend(loc=0)
        plt.tight_layout()
        plt.savefig(plot_dir + fit_func_name + '-' + surrogate_name + '-' + use + '.' + plot_ext)
        plt.close()

    print("all plotted")


def plot_by_use(data):
    """Create and save plots comparing the median convergence of `experiment_repetitions`
     runs for various uses of each surrogate"""

    fit_func_names = fit_funcs.keys()

    Index = namedtuple('Index', ['fitfunc', 'surrogate', 'usage', 'repetition', 'genint', 'lambda_pre'])

    np.set_printoptions(precision=3, linewidth=2000)

    for fit_func_name, surrogate_name, gen_int in product(fit_func_names, surrogates, gen_intervals):
        plt.figure(figsize=(16,9))
        num_plotted = 0

        for use, lambda_pre in product(uses, lambda_pres):
            total_data = []

            if surrogate_name == 'NoSurrogate' and use is not 'reg':
                continue
            elif use == 'EGO-reg' and surrogate_name not in ['Kriging', 'RandomForest']:
                continue

            for rep in range(experiment_repetitions):

                try:
                    idx = Index(fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre)
                    dat = data[idx]
                except:
                    continue
                dat = np.ma.masked_invalid(dat).min(axis=1)
                dat = np.minimum.accumulate(dat)
                total_data.append(dat)

            if not total_data:
                continue
            minimum, mean, median, maximum = getplottingvalues(total_data)

            plt.subplot(121)
            plt.plot(median, label=f'{use} l{lambda_pre}')
            plt.fill_between(np.arange(len(minimum)), minimum, maximum, interpolate=True, alpha=0.2)

            plt.subplot(122)
            plt.plot(mean, label=f'{use} l{lambda_pre}')
            plt.fill_between(np.arange(len(minimum)), minimum, maximum, interpolate=True, alpha=0.2)
            num_plotted += 1

        if num_plotted <= 1:
            plt.close()
            continue

        guaranteeFolderExists(f'{plot_dir}')
        plt.suptitle('Use of Surrogate comparison')
        plt.subplot(121)
        plt.title(f'{fit_func_name}-{surrogate_name}-{gen_int} - Medians')
        plt.xlabel('Evaluations')
        plt.ylabel('Fitness value')
        plt.yscale('log')
        plt.legend(loc=0)

        plt.subplot(122)
        plt.title(f'{fit_func_name}-{surrogate_name}-{gen_int} - Means')
        plt.xlabel('Evaluations')
        plt.ylabel('Fitness value')
        plt.yscale('log')
        plt.legend(loc=0)
        plt.tight_layout()
        plt.savefig(plot_dir + fit_func_name + '-' + surrogate_name + '-' + str(gen_int) + '.' + plot_ext)
        plt.close()

    print("all plotted")


def plot_by_surrogate(data):
    """Create and save plots comparing the median convergence of `experiment_repetitions`
     runs for various uses of each surrogate"""

    fit_func_names = fit_funcs.keys()

    Index = namedtuple('Index', ['fitfunc', 'surrogate', 'usage', 'repetition', 'genint', 'lambda_pre'])

    np.set_printoptions(precision=3, linewidth=2000)

    for fit_func_name, use, gen_int in product(fit_func_names, uses, gen_intervals):
        plt.figure(figsize=(16,9))
        num_plotted = 0

        for surrogate_name, lambda_pre in product(surrogates, lambda_pres):
            total_data = []

            if surrogate_name == 'NoSurrogate' and use is not 'reg':
                continue
            elif use == 'EGO-reg' and surrogate_name not in ['Kriging', 'RandomForest']:
                continue

            for rep in range(experiment_repetitions):

                try:
                    idx = Index(fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre)
                    dat = data[idx]
                except:
                    continue
                dat = np.ma.masked_invalid(dat).min(axis=1)
                dat = np.minimum.accumulate(dat)
                total_data.append(dat)

            if not total_data:
                continue
            minimum, mean, median, maximum = getplottingvalues(total_data)

            plt.subplot(121)
            plt.plot(median, label=f'{surrogate_name} l{lambda_pre}')
            plt.fill_between(np.arange(len(minimum)), minimum, maximum, interpolate=True, alpha=0.2)

            plt.subplot(122)
            plt.plot(mean, label=f'{surrogate_name} l{lambda_pre}')
            plt.fill_between(np.arange(len(minimum)), minimum, maximum, interpolate=True, alpha=0.2)
            num_plotted += 1

        if num_plotted <= 1:
            plt.close()
            continue

        guaranteeFolderExists(f'{plot_dir}')
        plt.suptitle('Surrogate model comparison')
        plt.subplot(121)
        plt.title(f'{fit_func_name}-{use}-{gen_int} - Medians')
        plt.xlabel('Evaluations')
        plt.ylabel('Fitness value')
        plt.yscale('log')
        plt.legend(loc=0)

        plt.subplot(122)
        plt.title(f'{fit_func_name}-{use}-{gen_int} - Means')
        plt.xlabel('Evaluations')
        plt.ylabel('Fitness value')
        plt.yscale('log')
        plt.legend(loc=0)
        plt.tight_layout()
        plt.savefig(plot_dir + fit_func_name + '-' + use + '-' + str(gen_int) + '.' + plot_ext)
        plt.close()

    print("all plotted")


def make2dvisualizations():
    from mpl_toolkits.mplot3d import Axes3D
    from matplotlib import cm
    from matplotlib.ticker import LinearLocator, FormatStrFormatter

    # for angle in [45, 135, 225, 315]:
    for fit_func_name in list(fit_funcs.keys())[:5]:
        fig = plt.figure()
        ax = fig.gca(projection='3d')

        x_min, y_min = fit_funcs[fit_func_name].l_bound
        x_max, y_max = fit_funcs[fit_func_name].u_bound

        # Make data.
        X = np.arange(x_min, x_max, (x_max-x_min)/100)
        Y = np.arange(y_min, y_max, (y_max-y_min)/100)
        X, Y = np.meshgrid(X, Y)
        fit_func = np.vectorize(lambda x, y: fit_funcs[fit_func_name].high((x,y)))
        Z = fit_func(X, Y)

        # Plot the surface.
        surf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm,
                               linewidth=0, antialiased=False)
        ax.view_init(azim=45)
        ax.set_title(f'{fit_func_name} (high fidelity)')

        ax.set_xlabel('x1')
        ax.set_ylabel('x2')
        ax.set_zlabel('f')

        # Customize the z axis.
        ax.zaxis.set_major_locator(LinearLocator(10))
        ax.zaxis.set_major_formatter(FormatStrFormatter('%.02f'))

        # Add a color bar which maps values to colors.
        fig.colorbar(surf, shrink=0.5, aspect=5)

        plt.tight_layout()
        plt.savefig(f'{plot_dir}{fit_func_name}_2d.{plot_ext}')
        # plt.show()


def run():
    data = getdata()
    plot_by_use(data)
    plot_by_genint(data)
    plot_by_surrogate(data)

    # make2dvisualizations()

    # for size in [10, 20, 30, 40, 50]:
    #     print(size)
        # plotSimpleComparisons(size)
        # plotMedianComparisons(size)
        # calcWinsPerStrategy(size)
        # plotBoxPlots(size)


if __name__ == '__main__':
    run()
