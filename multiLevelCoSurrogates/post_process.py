#!/usr/bin/python
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, print_function, unicode_literals

'''
post_process.py: This file is intended to perform some simple post-processing
                 based on the data files generated by the CMA-ES.
'''

__author__ = 'Sander van Rijn'
__email__ = 's.j.van.rijn@liacs.leidenuniv.nl'

from multiLevelCoSurrogates.config import experiment_repetitions, fit_funcs, fit_func_dims, folder_name, suffix, data_ext, plot_ext, data_dir, plot_dir, base_dir
from multiLevelCoSurrogates.__main__ import guaranteeFolderExists
from itertools import product
from matplotlib import pyplot as plt
from collections import Counter, namedtuple

from pprint import pprint
import numpy as np
import pandas as pd

surrogates = ['Kriging', 'RBF', 'RandomForest', 'NoSurrogate']  # , 'SVM'
# uses = ['reg', 'EGO-reg', 'MF', 'scaled-MF', 'MF-bisurr', 'scaled-MF-bisurr']
uses = ['reg', 'EGO-reg', 'scaled-MF']
gen_intervals = [0, 1, 2, 3, 5, 10, 20]
lambda_pres = [0, 2]  # , 4, 8]
figsize = (6, 4.5)

TimingData = namedtuple('TimingData', ['function', 'surrogate', 'usage', 'repetition', 'gen_int', 'lambda_pre', 'time'])

x_lims = {
    'bohachevsky': 100,
    'branin': 500,
    'booth': 250,
    'himmelblau': 500,
    'sixHumpCamelBack': 750,
    'park91a': 500,
    'park91b': 500,
    'borehole': 300,
}


def isTwoInts(value):
    """Returns True if the given value is a tuple or list consisting of exactly 2 integers"""
    return isinstance(value, (tuple, list)) \
           and len(value) == 2 \
           and all(isinstance(val, int) for val in value)


#TODO: rewrite to use slice()
def interpretColumn(column):
    """Interprets the 'column' argument of loadFitnessHistory into a start, end value pair"""
    if column is None:  # No specific column is requested, return everything
        start = 0
        end = None
    elif isinstance(column, int):  # One specific column is requested
        start = column
        end = column + 1
    elif isTwoInts(column):  # Multiple columns are requested
        start = column[0]
        end = column[1] + 1 if column[1] != -1 else None  # if -1 is given, we want up to and incl. the last column
    else:  # 'column' does not match expected format
        raise Exception("Invalid format for 'column': {col}".format(col=column))

    return start, end


def loadFitnessHistory(fname, column=None):
    """
    Return the data stored in the given filename as float values.
    Optionally, only data from a single, or range of columns can be selected.

    :param fname: The name of the file to retrieve the data from
    :param column:   Single or double integer to indicate desired column (optional)
    :return:         (Selected) data from the given file in 2D list format
    """

    start, end = interpretColumn(column)

    with open(fname, 'r') as f:
        next(f)  # Skip the first line which only contains header information
        return [list(map(float, line.split(' ')[start:end])) for line in f]


#=======================================================================================================================
#=======================================================================================================================
#=======================================================================================================================


def plotSimpleComparisons(training_size):
    """Create and save plots comparing convergence of different uses of the same surrogate"""

    fit_func_names = fit_funcs.keys()
    # surrogates = ['Kriging', 'RBF', 'RandomForest']
    # uses = ['reg', 'MF', 'scaled-MF']
    experiments = product(fit_func_names, surrogates, range(experiment_repetitions))

    for fit_func_name, surrogate_name, rep in experiments:
        print(fit_func_name, surrogate_name, rep)

        ndim = fit_func_dims[fit_func_name]
        fsuff = suffix.format(size=training_size, rep=rep)
        plt.figure()

        for use in uses:

            if surrogate_name == 'NoSurrogate' and use is not 'reg':
                continue
            elif use == 'EGO-reg' and surrogate_name is not 'Kriging':
                continue

            fname = folder_name.format(ndim=ndim, func=fit_func_name, use=use, surr=surrogate_name)
            filename_prefix = f'{data_dir}{fname}{fsuff}'

            data = np.array(loadFitnessHistory(filename_prefix + 'reslog.' + data_ext, column=(1, -1)))
            data = np.ma.masked_invalid(data).min(axis=1)
            data = np.minimum.accumulate(data)
            plt.plot(data, label=use)

        plot_folder = folder_name.format(ndim=ndim, func=fit_func_name, use='', surr=surrogate_name)
        plot_name_prefix = f'{plot_dir}{plot_folder}{fsuff}'
        guaranteeFolderExists(f'{plot_dir}{plot_folder}')
        plt.xlabel('Evaluations')
        plt.ylabel('Fitness value')
        plt.legend(loc=0)
        plt.savefig(plot_name_prefix + 'reslog.' + plot_ext)
        plt.close()


def plotMedianComparisons(training_size):
    """Create and save plots comparing the median convergence of `experiment_repetitions` runs for various uses of each surrogate"""

    fit_func_names = fit_funcs.keys()
    # surrogates = ['Kriging', 'RBF', 'RandomForest']
    # uses = ['reg', 'MF', 'scaled-MF']
    experiments = product(fit_func_names, surrogates)

    for fit_func_name, surrogate_name in experiments:
        print(fit_func_name, surrogate_name)

        ndim = fit_func_dims[fit_func_name]
        plt.figure()

        for use in uses:

            if surrogate_name == 'NoSurrogate' and use is not 'reg':
                continue
            elif use == 'EGO-reg' and surrogate_name is not 'Kriging':
                continue

            fname = folder_name.format(ndim=ndim, func=fit_func_name, use=use, surr=surrogate_name)
            total_data = []

            for rep in range(experiment_repetitions):
                fsuff = suffix.format(size=training_size, rep=rep)
                filename_prefix = f'{data_dir}{fname}{fsuff}'

                data = np.array(loadFitnessHistory(filename_prefix + 'reslog.' + data_ext, column=(1, -1)))
                data = np.ma.masked_invalid(data).min(axis=1)
                data = np.minimum.accumulate(data)
                total_data.append(data)

            min_idx = np.argmin(np.asarray([dat[-1] for dat in total_data]))
            plt.plot(total_data[min_idx], label=f'median {use}')


            # Make all arrays in total_data of equal length and calculate the average
            max_len = max([len(dat) for dat in total_data])
            new_data = []
            for dat in total_data:
                new_data.append(np.ma.append(dat, [dat[-1]] * (max_len - len(dat))))
            plt.plot(np.mean(np.vstack(new_data), axis=0), label=f'mean {use}')



        fsuff = suffix.format(size=training_size, rep='')
        plot_folder = f'{fit_func_name}-{surrogate_name}-'
        plot_name_prefix = f'{plot_dir}{plot_folder}{fsuff}'
        guaranteeFolderExists(f'{plot_dir}')
        plt.xlabel('Evaluations')
        plt.ylabel('Fitness value')
        plt.yscale('log')
        plt.legend(loc=0)
        plt.savefig(plot_name_prefix + 'reslog.' + plot_ext)
        plt.close()


def counterToFilledTupleList(counter):
    """Transform a counter into a list of (entry, count)-tuples, explicitly keeping 0-counts"""
    result = []
    for usage in ['reg', 'MF', 'scaled-MF']:
        result.append((usage, counter[usage]))
    return result


def calcWinsPerStrategy(training_size):
    """Compare the medians of `experiment_repetitions` runs of each use to determine 'wins', and plot these as a histogram"""

    fit_func_names = fit_funcs.keys()
    # surrogates = ['Kriging', 'RBF', 'RandomForest']
    # uses = ['reg', 'MF', 'scaled-MF']
    experiments = product(fit_func_names, surrogates)

    c = Counter()
    surr_c = {name: Counter() for name in surrogates}
    func_c = {name: Counter() for name in fit_func_names}

    for fit_func_name, surrogate_name in experiments:
        print(fit_func_name, surrogate_name)

        ndim = fit_func_dims[fit_func_name]
        best_res = {}

        for use in uses:

            fname = folder_name.format(ndim=ndim, func=fit_func_name, use=use, surr=surrogate_name)
            total_data = []

            for rep in range(experiment_repetitions):
                fsuff = suffix.format(size=training_size, rep=rep)
                filename_prefix = f'{data_dir}{fname}{fsuff}'

                data = np.array(loadFitnessHistory(filename_prefix + 'reslog.' + data_ext, column=(1, -1)))
                data = np.ma.masked_invalid(data).min(axis=1)
                data = np.minimum.accumulate(data)
                total_data.append(data)

            bests = np.asarray([dat[-1] for dat in total_data])
            best_res[use] = np.argsort(bests)[len(bests) // 2]

        if best_res['reg'] < best_res['MF'] and best_res['reg'] < best_res['scaled-MF']:
            c['reg'] += 1
            surr_c[surrogate_name]['reg'] += 1
            func_c[fit_func_name]['reg'] += 1
        elif best_res['MF'] < best_res['reg'] and best_res['MF'] < best_res['scaled-MF']:
            c['MF'] += 1
            surr_c[surrogate_name]['MF'] += 1
            func_c[fit_func_name]['MF'] += 1
        else:
            c['scaled-MF'] += 1
            surr_c[surrogate_name]['scaled-MF'] += 1
            func_c[fit_func_name]['scaled-MF'] += 1

    pprint(func_c)
    print()
    pprint(surr_c)
    print()
    pprint(c)

    plt.figure(figsize=(4,4))
    plt.suptitle(f'Wins per usage type, training size = {training_size}')
    plt.subplot(211)
    # plt.title('Combined wins per usage type')
    # ids, vals = zip(*counterToFilledTupleList(c))
    # plt.hist(range(len(ids)), weights=vals)
    # plt.xticks(range(len(ids)), ids)

    ax1 = plt.subplot(211)
    ax1.set_title('by surrogate')
    indices = []
    values = []
    labels = []
    for name, counter in surr_c.items():
        ids, vals = zip(*counterToFilledTupleList(counter))
        indices.append(range(len(ids)))
        values.append(vals)
        labels.append(name)
    ax1.hist(indices, bins=np.arange(4)-.5, weights=values, label=labels, stacked=True, align='mid', rwidth=.5)
    ax1.set_xticks(range(len(ids)))
    ax1.set_xticklabels(ids)

    ax2 = plt.subplot(212)
    ax2.set_title('by benchmark function')
    indices = []
    values = []
    labels = []
    for name, counter in func_c.items():
        ids, vals = zip(*counterToFilledTupleList(counter))
        indices.append(range(len(ids)))
        values.append(vals)
        labels.append(name)
    ax2.hist(indices, bins=np.arange(4)-.5, weights=values, label=labels, stacked=True, align='mid', rwidth=.5)
    ax2.set_xticks(range(len(ids)))
    ax2.set_xticklabels(ids)

    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    # plt.tight_layout()
    #
    # box = ax1.get_position()
    # ax1.set_position([box.x0, box.y0, box.width * 0.65, box.height])
    # ax1.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    #
    # box = ax2.get_position()
    # ax2.set_position([box.x0, box.y0, box.width * 0.65, box.height])
    # ax2.legend(loc='center left', bbox_to_anchor=(1, 0.5))


    fsuff = suffix.format(size=training_size, rep='')
    plot_name_prefix = f'{plot_dir}{fsuff}'
    guaranteeFolderExists(f'{plot_dir}')
    plt.savefig(plot_name_prefix + 'reslog-histogram_no-legend.' + plot_ext)


def plotBoxPlots(training_size):
    """Create and save boxplots for the final fitness levels and time to convergence"""

    fit_func_names = fit_funcs.keys()
    # surrogates = ['Kriging', 'RBF', 'RandomForest']
    # uses = ['reg', 'MF', 'scaled-MF']
    experiments = product(fit_func_names, surrogates)

    for fit_func_name, surrogate_name in experiments:
        print(fit_func_name, surrogate_name)

        plt.figure()
        ndim = fit_func_dims[fit_func_name]
        bests = []
        lengths = []

        for use in uses:

            if surrogate_name == 'NoSurrogate' and use is not 'reg':
                continue
            if use == 'EGO-reg' and surrogate_name is not 'Kriging':
                continue
            fname = folder_name.format(ndim=ndim, func=fit_func_name, use=use, surr=surrogate_name)
            total_data = []
            total_lengths = []

            for rep in range(experiment_repetitions):
                fsuff = suffix.format(size=training_size, rep=rep)
                filename_prefix = f'{data_dir}{fname}{fsuff}'

                data = np.array(loadFitnessHistory(filename_prefix + 'reslog.' + data_ext, column=(1, -1)))
                total_lengths.append(len(data))
                data = np.ma.masked_invalid(data).min(axis=1)
                data = np.minimum.accumulate(data)
                total_data.append(data)

            bests.append(np.array([dat[-1] for dat in total_data]))
            lengths.append(total_lengths)

        if surrogate_name == 'Kriging':
            labels = uses
        elif surrogate_name == 'NoSurrogate':
            labels = uses[:1]
        else:
            labels = uses[:3]

        plt.subplot(211)
        plt.title("Fitness values")
        plt.boxplot(bests, labels=labels)
        plt.yscale('log')

        plt.subplot(212)
        plt.title("Time to convergence")
        plt.boxplot(lengths, labels=labels)

        plt.tight_layout()
        fsuff = suffix.format(size=training_size, rep='')
        plot_folder = f'{fit_func_name}-{surrogate_name}-'
        plot_name_prefix = f'{plot_dir}{plot_folder}{fsuff}'
        guaranteeFolderExists(f'{plot_dir}')
        plt.savefig(plot_name_prefix + 'reslog-boxplot.' + plot_ext)
        plt.close()



def getdata():

    fit_func_names = fit_funcs.keys()
    experiments = product(fit_func_names, surrogates, uses, range(experiment_repetitions), gen_intervals, lambda_pres)

    Index = namedtuple('Index', ['fitfunc', 'surrogate', 'usage', 'repetition', 'genint', 'lambda_pre'])
    data = {}

    for fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre_mul in experiments:
        idx = Index(fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre_mul)
        ndim = fit_func_dims[fit_func_name]
        lambda_pre = (4 + int(3 * np.log(ndim))) * lambda_pre_mul

        if surrogate_name == 'NoSurrogate' and use is not 'reg':
            continue
        elif use == 'EGO-reg' and surrogate_name not in ['Kriging', 'RandomForest']:
            continue

        fname = folder_name.format(ndim=ndim, func=fit_func_name, use=use, surr=surrogate_name)
        fsuff = suffix.format(size=lambda_pre, rep=rep, gen=gen_int)
        filename_prefix = f'{base_dir}data/{fname}{fsuff}'

        try:
            data[idx] = np.array(loadFitnessHistory(filename_prefix + 'reslog.' + data_ext, column=(1, -1)))
            if fit_func_name == 'borehole':
                data[idx] *= -1
            elif fit_func_name == 'park91b':
                data[idx] -= 0.666666666666  # Manually extracted minimum found value...
            elif fit_func_name == 'branin':
                data[idx] += 320.731611436  # Manually extracted minimum found value...
        except:
            pass

    print("done")
    return data


def timingdatatocsv():

    fit_func_names = fit_funcs.keys()
    experiments = product(fit_func_names, surrogates, uses, range(experiment_repetitions), gen_intervals, lambda_pres)
    data = []

    for fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre_mul in experiments:
        ndim = fit_func_dims[fit_func_name]
        lambda_pre = (4 + int(3 * np.log(ndim))) * lambda_pre_mul

        if surrogate_name == 'NoSurrogate' and use is not 'reg':
            continue
        elif use == 'EGO-reg' and surrogate_name not in ['Kriging', 'RandomForest']:
            continue

        fname = folder_name.format(ndim=ndim, func=fit_func_name, use=use, surr=surrogate_name)
        fsuff = suffix.format(size=lambda_pre, rep=rep, gen=gen_int)
        filename_prefix = f'{data_dir}{fname}{fsuff}'

        try:
            # In this case, we only ever expect a single value per file
            time = np.array(loadFitnessHistory(filename_prefix + 'timelog.' + data_ext, column=(1, -1)))[0][0]
            tup = TimingData(fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre_mul, time)
            data.append(tup)
        except:
            pass

    df = pd.DataFrame(data, columns=TimingData._fields)
    df.to_csv(f'{data_dir}timing_summary.csv')

    print("done")


def getplottingvalues(total_data, min_perc=25, max_perc=75):

    max_len = max([len(dat) for dat in total_data])
    new_data = [dat.tolist() + [dat[-1]]*(max_len - len(dat)) for dat in total_data]
    new_data = np.stack(new_data)

    # Workaround to prevent negative values

    true_min = np.min(new_data)
    if true_min <= 0:
        # print(true_min)
        positive = new_data > 0
        try:
            min_pos = np.min(new_data[positive])
        except Exception as e:
            print(new_data)
            print(new_data[positive])
        new_data[~positive] = min_pos

    minimum = np.percentile(new_data, min_perc, axis=0)
    mean = np.mean(new_data, axis=0)
    median = np.percentile(new_data, 50, axis=0)
    maximum = np.percentile(new_data, max_perc, axis=0)

    return minimum, mean, median, maximum


def compare_by_genint(data):
    """Create and save plots comparing the median convergence of `experiment_repetitions`
     runs for various uses of each surrogate"""

    fit_func_names = fit_funcs.keys()
    Index = namedtuple('Index', ['fitfunc', 'surrogate', 'usage', 'repetition', 'genint', 'lambda_pre'])
    np.set_printoptions(precision=3, linewidth=2000)

    for fit_func_name, surrogate_name, use in product(fit_func_names, surrogates, uses):

        if surrogate_name == 'NoSurrogate' and use is not 'reg':
            continue
        elif use == 'EGO-reg' and surrogate_name not in ['Kriging', 'RandomForest']:
            continue

        plt.figure(figsize=figsize)
        num_plotted = 0

        for gen_int, lambda_pre in product(gen_intervals, lambda_pres):
            total_data = []

            for rep in range(experiment_repetitions):
                try:
                    idx = Index(fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre)
                    dat = data[idx]
                except:
                    continue
                dat = np.ma.masked_invalid(dat).min(axis=1)
                dat = np.minimum.accumulate(dat)
                total_data.append(dat)

            if not total_data:
                continue
            minimum, mean, median, maximum = getplottingvalues(total_data)
            plt.plot(median, label='g_int='+str(gen_int))
            plt.fill_between(np.arange(len(minimum)), minimum, maximum, interpolate=True, alpha=0.2)
            num_plotted += 1

        if num_plotted <= 1:
            plt.close()
            continue

        guaranteeFolderExists(f'{plot_dir}by_genint/')
        plt.title(f'{fit_func_name}')
        plt.xlabel('Evaluations')
        plt.xlim(0, x_lims[fit_func_name])
        plt.ylabel('Fitness value')
        plt.yscale('log')
        plt.legend(loc=0)

        plt.tight_layout()
        plt.savefig(plot_dir + 'by_genint/' + fit_func_name + '-' + surrogate_name + '-' + use + '.' + plot_ext)
        plt.close()

    print("all plotted")


def compare_by_use(data):
    """Create and save plots comparing the median convergence of `experiment_repetitions`
     runs for various uses of each surrogate"""

    fit_func_names = fit_funcs.keys()
    Index = namedtuple('Index', ['fitfunc', 'surrogate', 'usage', 'repetition', 'genint', 'lambda_pre'])
    np.set_printoptions(precision=3, linewidth=2000)

    for fit_func_name, gen_int_ in product(fit_func_names, gen_intervals):
        plt.figure(figsize=figsize)
        num_plotted = 0

        for surrogate_name, use, lambda_pre, gen_int in product(surrogates, uses, lambda_pres, [gen_int_]):
            total_data = []

            if surrogate_name == 'NoSurrogate' and use is not 'reg':
                continue
            elif use == 'EGO-reg' and surrogate_name not in ['Kriging', 'RandomForest']:
                continue

            for rep in range(experiment_repetitions):
                try:
                    idx = Index(fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre)
                    dat = data[idx]
                except:
                    continue
                try:
                    dat = np.ma.masked_invalid(dat).min(axis=1)
                    dat = np.minimum.accumulate(dat)
                    total_data.append(dat)
                except Exception as e:
                    print(idx)
                    print(dat)

            if not total_data:
                continue
            minimum, mean, median, maximum = getplottingvalues(total_data)
            plt.plot(median, label=f'{surrogate_name} - {"c" if use != "reg" else ""}SA-CMA-ES')
            plt.fill_between(np.arange(len(minimum)), minimum, maximum, interpolate=True, alpha=0.2)
            num_plotted += 1

        if num_plotted <= 1:
            plt.close()
            continue

        guaranteeFolderExists(f'{plot_dir}by_use/')
        plt.title(f'{fit_func_name}')
        plt.xlabel('Evaluations')
        plt.xlim(0, x_lims[fit_func_name])
        plt.ylabel('Fitness value')
        plt.yscale('log')
        plt.legend(loc=0)

        plt.tight_layout()
        plt.savefig(plot_dir + 'by_use/' + fit_func_name + '-' + '-' + str(gen_int_) + '.' + plot_ext)
        plt.close()

    print("all plotted")


def compare_by_surrogate(data):
    """Create and save plots comparing the median convergence of `experiment_repetitions`
     runs for various uses of each surrogate"""

    fit_func_names = fit_funcs.keys()
    Index = namedtuple('Index', ['fitfunc', 'surrogate', 'usage', 'repetition', 'genint', 'lambda_pre'])
    np.set_printoptions(precision=3, linewidth=2000)

    for fit_func_name, use, gen_int_ in product(fit_func_names, uses, gen_intervals):
        plt.figure(figsize=figsize)
        num_plotted = 0

        for surrogate_name, lambda_pre, gen_int in product(surrogates, lambda_pres, [0, gen_int_]):
            total_data = []

            if use == 'EGO-reg' and surrogate_name not in ['Kriging', 'RandomForest']:
                continue

            for rep in range(experiment_repetitions):
                try:
                    idx = Index(fit_func_name, surrogate_name, use, rep, gen_int, lambda_pre)
                    dat = data[idx]
                except:
                    continue
                dat = np.ma.masked_invalid(dat).min(axis=1)
                dat = np.minimum.accumulate(dat)
                total_data.append(dat)

            if not total_data:
                continue

            minimum, mean, median, maximum = getplottingvalues(total_data)
            plt.plot(median, label=f'{surrogate_name}')
            plt.fill_between(np.arange(len(minimum)), minimum, maximum, interpolate=True, alpha=0.2)
            num_plotted += 1

        if num_plotted <= 1:
            plt.close()
            continue

        guaranteeFolderExists(f'{plot_dir}by_surrogate/')
        plt.title(f'{fit_func_name}')
        plt.xlabel('Evaluations')
        plt.xlim(0, x_lims[fit_func_name])
        plt.ylabel('Fitness value')
        plt.yscale('log')
        plt.legend(loc=0)

        plt.tight_layout()
        plt.savefig(plot_dir + 'by_surrogate/' + fit_func_name + '-' + use + '-' + str(gen_int) + '.' + plot_ext)
        plt.close()

    print("all plotted")


def make2dvisualizations(function, l_bound, u_bound, name):
    from mpl_toolkits.mplot3d import Axes3D
    from matplotlib import cm
    from matplotlib.ticker import LinearLocator, FormatStrFormatter

    function = np.vectorize(function)
    fig = plt.figure()
    ax = fig.gca(projection='3d')

    x_min, y_min = l_bound
    x_max, y_max = u_bound

    # Make data.
    X = np.arange(x_min, x_max, (x_max-x_min)/100)
    Y = np.arange(y_min, y_max, (y_max-y_min)/100)
    X, Y = np.meshgrid(X, Y)

    Z = function(X, Y)

    # Plot the surface.
    surf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm,
                           linewidth=0, antialiased=False)
    ax.view_init(azim=45)
    ax.set_title(f'{name}')

    ax.set_xlabel('x1')
    ax.set_ylabel('x2')
    ax.set_zlabel('f')

    # Customize the z axis.
    ax.zaxis.set_major_locator(LinearLocator(10))
    ax.zaxis.set_major_formatter(FormatStrFormatter('%.02f'))

    # Add a color bar which maps values to colors.
    fig.colorbar(surf, shrink=0.5, aspect=5)

    plt.tight_layout()
    plt.savefig(f'{plot_dir}{name}_2d.{plot_ext}')


def run():
    # data = getdata()
    # compare_by_use(data)
    # compare_by_genint(data)
    # compare_by_surrogate(data)
    #
    # for fit_func_name in list(fit_funcs.keys())[:5]:
    #     func = lambda x, y: fit_funcs[fit_func_name].high((x,y))
    #     make2dvisualizations(func, fit_funcs[fit_func_name].l_bound, fit_funcs[fit_func_name].u_bound, fit_func_name)
    #     func = lambda x, y: fit_funcs[fit_func_name].low((x,y))
    #     make2dvisualizations(func, fit_funcs[fit_func_name].l_bound, fit_funcs[fit_func_name].u_bound, fit_func_name + '_low')

    # for size in [10, 20, 30, 40, 50]:
    #     print(size)
        # plotSimpleComparisons(size)
        # plotMedianComparisons(size)
        # calcWinsPerStrategy(size)
        # plotBoxPlots(size)

    timingdatatocsv()


if __name__ == '__main__':
    run()
